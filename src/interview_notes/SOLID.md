[Single Responsibility](https://ilclubdellesei.wordpress.com/2017/07/05/solid-principles-by-examples-single-responsability/)

The primary benefit the Single-Responsibility Principle gives you is high-cohesion, low-coupling code. Following SRP minimizes that one class will have to change for a given requirement, and maximizes the possibility that changing one class will not impact any other classes.

[open/closed](https://ilclubdellesei.wordpress.com/2017/07/10/solid-principles-by-examples-openclosed/)

The OCP makes our code more reusable and less coupled. This way we can write new code that with little impact in our existing codebase. SRP and OCP are closely related parents and their application makes our code more clean and mantainable.

[Liskov Substitution ](https://ilclubdellesei.wordpress.com/2017/08/17/solid-principles-by-examples-liskov-substitution-principle/)



[Interface Segregation](https://ilclubdellesei.wordpress.com/2017/09/02/solid-principles-by-example-interface-segregation/)

The ISP guides us to create many _small_ interfaces with coherent functionalities instead of a few _big_ interfaces with lots of different methods. When we apply the ISP, class and their dependencies communicate using focussed interfaces, minimising dependencies. Smaller interfaces are easier to implement, improving flexibility and the possibility of reuse.

[Dependency Injection](https://ilclubdellesei.wordpress.com/2017/09/05/solid-principles-by-example-dependency-inversion/)

The word Inversion comes from the fact that both the high-level and the low-level depend on abstraction and this is the opposite of the classical approach where the high-level classes depend on the low-level classes.



> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE3NjcwNjkwOTldfQ==
-->